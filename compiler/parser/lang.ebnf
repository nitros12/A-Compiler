@@grammar :: Wew
@@comments :: /{~(\n|.)*~}/
@@eol_comments :: /\/\/.*?$/
@@left_recursion :: False
@@parseinfo :: True

start = {decl}+ $ ;


base_type = t:('u1' | 'u2' | 'u4' | 'u8' | 's1' | 's2' | 's4' | 's8') ;


ptr_type = '*' t:type ;


const_type = '|' t:type '|' ;


array_type = '[' t:type ['@' s:int] ']' ;


fun_type = '(' t:','.{type} ')' '->' r:type ;


type = base_type | ptr_type | array_type | const_type | fun_type | '(' type ')' ;


statement = (var_decl | scope | if_stmt | loop_stmt | return_stmt) [';'] | expr ';' ;


scope = '{' body:{statement} '}' ;


elif = 'elif' e:expr t:scope ;
if_stmt = 'if' ~ e:expr t:scope elf:{elif} ['else' f:scope] ;


loop_stmt = 'while' ~ e:expr t:scope ;


return_stmt = 'return' ~ e:expr ;


expr = assign_expr | logical ;


fun_decl = 'fn' ~ name:name '(' params:','.{name ':' type} ')' '->' r:type >scope ;


optional_def = ':=' ~ val:expr typ:`'infer'` | ':' typ:type ['=' val:expr] ;


var_decl = 'var' ~ name:name >optional_def ;


decl = (fun_decl | var_decl) [';'] ;


assign_expr = left:logical_pre op:'=' right:expr ;


logical_pre = logical | boolean_pre ;
logical = ('|' | '^' | '&')>{boolean_pre}+ ;
boolean_pre = boolean | equality_pre ;
boolean = ('or' | 'and')>{equality_pre}+ ;
equality_pre = equality | relation_pre ;
equality = ('!=' | '==')<{relation_pre}+ ;
relation_pre = relation | bitshift_pre ;
relation = ('<=' | '>=' | '<' | '>')<{bitshift_pre}+ ;
bitshift_pre = bitshift | additive_pre ;
bitshift = ('>>' | '<<')<{additive_pre}+ ;
additive_pre = additive | multiply_pre ;
additive = ('+' | '-')<{multiply_pre}+ ;
multiply_pre = multiply | unop_pre ;
multiply = ('*' | '/')<{unop_pre}+ ;

unop_pre = prefix | postop ;

prefix = op:('*' | '--' | '++' | '~' | '!' | '-' | '&' | '+') right:unop_pre ;


postop = postfix | singular ;


postfixexpr = | '(' args:','.{expr} ')' type:`'f'`
    | '[' ~ args:expr ']' type:`'b'`
    | op:'++' type:`'d'`
    | op:'--' type:`'d'`
    | op:':::' ~ t:type type:`'c'`
    | op:'::' ~ t:type type:`'c'` ;


postfix = left:singular exprs:{postfixexpr} ;


singular = literal | identifier | subexpr ;


subexpr = '(' @:expr ')' ;


literal = int_lit | str | chr | arr_lit ;


arr_lit = '{' obj:','.{expr} '}' ;


int = /-?\d+/ ;


int_lit = val:(>int) ['/' type:base_type] ;


str = str:/".+"/ ;


chr = chr:/'.'/ ;


name = /[A-Za-z]\w*/ ;


identifier = identifier:name ;
