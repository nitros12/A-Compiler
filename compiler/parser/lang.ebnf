@@grammar :: Wew

@@comments :: /{~(\n|.)*~}/
@@eol_comments :: /~~.*?$/

@@parseinfo :: True

start = {decl}+ $ ;

base_type
  =
  | 'u1'
  | 'u2'
  | 'u4'
  | 'u8'
  | 's1'
  | 's2'
  | 's4'
  | 's8'
  ;

ptr_type = "*" t:type ;

const_type = "|" t:type "|" ;

array_type = "[" t:type ["@" s:int] "]"  ;

fun_type = "(" t:','.{type} ')' '->' r:type ;

type
  =
  | base_type
  | ptr_type
  | array_type
  | const_type
  | fun_type
  | "(" type ")"
  ;

statement
  =
  ( var_decl
  | scope
  | if_stmt
  | loop_stmt
  | return_stmt
  | expression_stmt
  ) [';']  # semicolon is optional
  ;

scope
  = '{' body:{statement}* '}'
  ;

if_stmt
  = "if" ~ e:expr t:scope ['else' f:scope]
  ;

loop_stmt
  =
  "while" ~ e:expr t:scope
  ;

return_stmt = "return" ~ e:expr ;

expression_stmt
  =
  expr
  ;

expr
  =
  | assign_expr
  | logical
  ;

fun_decl
  = "fn" ~ name:name '(' params:','.{name ':' type} ')' '->' r:type >scope
  ;

optional_def
  =
  | ":" typ:type ["=" val:expr]  # static
  | ":=" ~ val:expr typ:`infer`  # inferred
  ;

var_decl
  = "var" ~ name:name >optional_def
  ;

decl
  =
  ( fun_decl
  | var_decl
  ) [';']
  ;

assign_expr
  = left:logical op:'=' right:expr
  ;

logical
  =
  | bitwise
  | boolean
  | comparison
  ;

bitwise
  =
  left:comparison op:('|' |
                      '^' |
                      '&' ) right:logical
  ;

boolean
  =
  left:comparison op:('||' | '&&') ~ right:logical
  ;

comparison
  =
  | equality
  | relation
  | shift
  ;

equality
  =
  left:shift op:('!=' |
                 '==' ) ~ right:comparison
  ;

relation
  =
  left:shift op:('<=' |
                 '>=' |
                 '<'  |
                 '>'  ) ~ right:comparison
  ;

shift
  =
  | bitshift
  | binop
  ;

bitshift
  =
  left:binop op:('>>' | '<<') ~ right:shift
  ;

binop
  =
  | additive
  | multiplicative
  ;

additive
  =
  left:multiplicative op:('+' | '-') ~ right:binop
  ;

multiplicative
  =
  | multiply
  | unop
  ;

multiply
  =
  left:unop op:('*' | '/') right:multiplicative
  ;

unop
  =
  | prefix
  | postop
  ;

prefix
  =
  op:('*'  |
      '--' |
      '++' |
      '~'  |
      '!'  |
      '-'  |
      '+'  ) ~ right:unop
  ;

postop
  =
  | postfix
  | singular
  ;

postfix
  =
  | left:postop '(' args:','.{expr} ')' type:`f`
  | left:postop '[' ~ args:expr ']' type:`b`
  | left:postop op:'++' type:`d`
  | left:postop op:'--' type:`d`
  | left:postop op:':::' ~ t:type type:`c`  # reinterpret expr
  | left:postop op:'::' ~ t:type type:`c`  # cast expr
  ;

singular
  =
  | literal
  | identifier
  | subexpr
  ;

subexpr
  =
  '(' @:expr ')'
  ;

literal
 =
 | int_lit
 | str
 | chr
 | arr_lit
 ;

# array literals will be pointers if in an expression, otherwise expand into index setting if on rhs of an initialisation
arr_lit
  =
  '{' obj:','.{expr} '}'
  ;

int = /\d+/ ;
int_lit = val:(>int) ['/' type:base_type] ;
str = str:/".+"/ ;
chr = chr:/'.'/ ;
name = /[A-Za-z]\w*/ ;
identifier = identifier:name ;
