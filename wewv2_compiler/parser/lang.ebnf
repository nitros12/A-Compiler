@@grammar :: Wew

@@comments :: /{~(\n|.)*~}/
@@eol_comments :: /\/\/.*?$/

@@parseinfo :: True

start = {statement}+ $ ;

base_type
  =
  | 'u1'
  | 'u2'
  | 'u4'
  | 'u8'
  | 's1'
  | 's2'
  | 's4'
  | 's8'
  ;

ptr_type = "*" t:type ;

const_type = "|" t:type "|" ;

array_type = "[" t:type "]" ["@" s:int] ;

fun_type = "(" t:','.{type} ')' '->' r:type ;

type
  =
  | base_type
  | ptr_type
  | array_type
  | const_type
  | fun_type
  | "(" type ")"
  ;

statement
  =
  | scope
  | if_stmt
  | loop_stmt
  | return_stmt
  | expression_stmt
  ;

scope
  = '{' body:{statement}+ '}'
  ;

if_stmt
  = "if" ~ '(' e:expr ')' t:scope ['else' f:scope]
  ;

loop_stmt
  =
  "while" ~ '(' e:expr ')' >scope
  ;

return_stmt = "return" ~ e:expr ';' ;

expression_stmt
  =
  expr ';'
  ;

expr
  =
  | decl
  | assign_expr
  | logical
  ;

fun_decl
  = "fn" ~ name:identifier '(' params:','.{n:identifier ':' t:type} ')' '->' r:type ">" >scope
  ;

var_decl
  = "var" ~ name:identifier init:optional_def
  ;


optional_def
  =
  | ":" typ:type ["=" val:expr]  # static
  | ":=" ~ val:expr typ:`infer`  # inferred
  ;

decl
  =
  | fun_decl
  | var_decl
  ;

assign_expr
  = left:logical op:'=' right:expr
  ;

logical
  =
  | bitwise
  | boolean
  | comparison
  ;

bitwise
  =
  | left:comparison op:'|' right:logical
  | left:comparison op:'^' right:logical
  | left:comparison op:'&' right:logical
  ;

boolean
  =
  | left:comparison op:'||' ~ right:logical
  | left:comparison op:'&&' ~ right:logical
  ;

comparison
  =
  | equality
  | relation
  | shift
  ;

equality
  =
  | left:shift op:'!=' ~ right:comparison
  | left:shift op:'==' ~ right:comparison
  ;

relation
  =
  | left:shift op:'=<' ~ right:comparison
  | left:shift op:'=>' ~ right:comparison
  | left:shift op:'<' ~ right:comparison
  | left:shift op:'>' ~ right:comparison
  ;

shift
  =
  | bitshift
  | binop
  ;

bitshift
  =
  | left:binop op:'>>' ~ right:shift
  | left:binop op:'<<' ~ right:shift
  ;

binop
  =
  | additive
  | multiplicative
  ;

additive
  =
  | left:multiplicative op:'+' ~ right:binop
  | left:multiplicative op:'-' ~ right:binop
  ;

multiplicative
  =
  | multiply
  | unop
  ;

multiply
  =
  | left:unop op:'*' right:multiplicative
  | left:unop op:'/' right:multiplicative
  ;

unop
  =
  | prefix
  | postfix
  ;

prefix
  =
  | op:'*' ~ right:unop
  | op:'--' ~ right:unop
  | op:'++' ~ right:unop
  | op:'~' ~ right:unop
  | op:'!' ~ right:unop
  | op:'-' ~ right:unop
  | op:'+' ~ right:unop
  | op:'cast' ~ '<' t:type '>' right:unop
  | op:'interpret' ~ '<' t:type '>' right:unop
  ;

postfix
  =
  | postop
  | singular
  ;

postop
  =
  | left:postfix '(' args:','.{expr} ')' type:`f`
  | left:postfix '[' ~ args:expr ']' type:`b`
  | left:postfix op:'++' type:`d`
  | left:postfix op:'--' type:`d`
  ;

singular
  =
  | literal
  | identifier
  | subexpr
  ;

subexpr
  =
  '(' @:expr ')'
  ;

literal
 =
 | val:int type:`int`
 | val:str type:`str`
 | val:chr type:`chr`
 | val:arr_lit type:`arr`
 ;

# array literals will be pointers if in an expression, otherwise expand into index setting if on rhs of an initialisation
arr_lit
  =
  '{' obj:','.{n:expr} '}'
  ;

int = /\d+/ ;
str = /".+"/ ;
chr = /'.'/ ;

identifier = /[A-Za-z]\w*/;