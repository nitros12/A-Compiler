@@grammar :: Wew

@@comments :: /{~(\n|.)*~}/
@@eol_comments :: /\/\/.*?$/

#@@parseinfo :: False

start = {statement}+ $ ;

base_type
  =
  | 'u2'
  | 'u4'
  | 's2'
  | 's4'
  ;

ptr_type = "*" t:type ;

array_type = "[" t:type "]" ["@" s:int] ;

fun_type = "(" t:','.{type} ')' '->' r:type ;

type
  =
  | base_type
  | ptr_type
  | array_type
  | fun_type
  | "(" type ")"
  ;

statement
  =
  | scope
  | if_stmt
  | loop_stmt
  | return_stmt
  | expression_stmt
  ;

scope
  = '{' body:{statement}+ '}'
  ;

if_stmt
  = 'if' ~ '(' e:expr ')' t:scope ['else' f:scope]
  ;

loop_stmt
  =
  'while' ~ '(' e:expr ')' >scope
  ;

return_stmt = 'return' ~ e:expr ';' ;

expression_stmt
  =
  expr ';'
  ;

expr
  =
  | decl 
  | assign_expr
  | logical
  ;

fun_decl
  = "fn" ~ name:identifier '(' args:','.{n:identifier ':' t:type} ')' '->' r:type ">" >scope
  ;

var_decl
  = "var" ~ name:identifier init:optional_def
  ;

optional_def
  =
  | ":" typ:type ["=" val:expr]
  | ":=" ~ val:expr typ:`infer`
  ;

decl
  =
  | fun_decl
  | var_decl
  ;
  
assign_expr
  = left:logical op:'=' right:expr
  ;

logical
  =
  | bitwise
  | boolean
  | comparison
  ;

bitwise
  =
  | left:comparison op:'|' right:logical
  | left:comparison op:'^' right:logical
  | left:comparison op:'&' right:logical
  ;

boolean
  =
  | left:comparison op:'||' right:logical
  | left:comparison op:'&&' right:logical
  ;

comparison
  =
  | equality
  | relation
  | shift
  ;

equality
  =
  | left:shift op:'!=' right:comparison
  | left:shift op:'==' right:comparison
  ;

relation
  =
  | left:shift op:'=<' right:comparison
  | left:shift op:'=>' right:comparison
  | left:shift op:'<' right:comparison
  | left:shift op:'>' right:comparison
  ;

shift
  =
  | bitshift
  | binop
  ;

bitshift
  =
  | left:binop op:'>>' right:shift
  | left:binop op:'<<' right:shift
  ;

binop
  =
  | additive
  | multiplicative
  ;

additive
  =
  | left:multiplicative op:'+' right:binop
  | left:multiplicative op:'-' right:binop
  ;

multiplicative
  =
  | multiply
  | unop
  ;

multiply
  =
  | left:unop op:'*' right:multiplicative
  | left:unop op:'/' right:multiplicative
  ;

unop
  =
  | prefix
  | postfix
  ;

prefix
  =
  | op:'*' right:unop
  | op:'--' right:unop
  | op:'++' right:unop
  | op:'~' right:unop
  | op:'!' right:unop
  | op:'-' right:unop
  | op:'+' right:unop
  ;

postfix
  =
  | postop
  | singular
  ;

postop
  =
  | left:postfix '(' args:','.{expr} ')' type:`f`
  | left:postfix '[' ~ args:expr ']' type:`b`
  | left:postfix op:'++' type:`d`
  | left:postfix op:'--' type:`d`
  ;

singular
  =
  | literal
  | identifier
  | subexpr
  ;

subexpr
  =
  '(' @:expr ')'
  ;

literal
 =
 | val:int type:`int`
 | val:str type:`str`
 | val:chr type:`chr`
 ;

int = /\d+/ ;
str = /".+"/ ;
chr = /'.'/ ;

identifier = /[A-Za-z]\w*/;