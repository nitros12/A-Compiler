@@grammar :: Wew

@@comments :: /{~(\n|.)*~}/
@@eol_comments :: /\/\/.*?$/

@@parseinfo :: True

start = {statement}+ $ ;

base_type
  =
  | 'u1'
  | 'u2'
  | 'u4'
  | 'u8'
  | 's1'
  | 's2'
  | 's4'
  | 's8'
  ;

ptr_type = "*" t:type ;

const_type = "|" t:type "|" ;

array_type = "[" t:type ["@" s:int] "]"  ;

fun_type = "(" t:','.{type} ')' '->' r:type ;

type
  =
  | base_type
  | ptr_type
  | array_type
  | const_type
  | fun_type
  | "(" type ")"
  ;

statement
  =
  | scope
  | if_stmt
  | loop_stmt
  | return_stmt
  | expression_stmt
  ;

scope
  = '{' body:{statement}+ '}'
  ;

if_stmt
  = "if" ~ '(' e:expr ')' t:scope ['else' f:scope]
  ;

loop_stmt
  =
  "while" ~ '(' e:expr ')' >scope
  ;

return_stmt = "return" ~ e:expr ';' ;

expression_stmt
  =
  expr ';'
  ;

expr
  =
  | decl
  | assign_expr
  | logical
  ;

fun_decl
  = "fn" ~ name:identifier '(' params:','.{n:identifier ':' t:type} ')' '->' r:type ">" >scope
  ;

var_decl
  = "var" ~ name:identifier init:optional_def
  ;


optional_def
  =
  | ":" typ:type ["=" val:expr]  # static
  | ":=" ~ val:expr typ:`infer`  # inferred
  ;

decl
  =
  | fun_decl
  | var_decl
  ;

assign_expr
  = left:logical op:'=' right:expr
  ;

logical
  =
  | bitwise
  | boolean
  | comparison
  ;

bitwise
  =
  left:comparison op:('|' |
                      '^' |
                      '&' ) right:logical
  ;

boolean
  =
  left:comparison op:('||' | '&&') ~ right:logical
  ;

comparison
  =
  | equality
  | relation
  | shift
  ;

equality
  =
  left:shift op:('!=' |
                 '==' ) ~ right:comparison
  ;

relation
  =
  left:shift op:('=<' |
                 '=>' |
                 '<'  |
                 '>'  ) ~ right:comparison
  ;

shift
  =
  | bitshift
  | binop
  ;

bitshift
  =
  left:binop op:('>>' | '<<') ~ right:shift
  ;

binop
  =
  | additive
  | multiplicative
  ;

additive
  =
  left:multiplicative op:('+' | '-') ~ right:binop
  ;

multiplicative
  =
  | multiply
  | unop
  ;

multiply
  =
  left:unop op:('*' | '/') right:multiplicative
  ;

unop
  =
  | prefix
  | postop
  ;

prefix
  =
  | op:('*'  |
        '--' |
        '++' |
        '~'  |
        '!'  |
        '-'  |
        '+'  ) ~ right:unop
  | op:('cast' |
        'interpret' ) ~ '<' t:type '>' right:unop
  ;

postop
  =
  | postfix
  | singular
  ;

postfix
  =
  | left:postop '(' args:','.{expr} ')' type:`f`
  | left:postop '[' ~ args:expr ']' type:`b`
  | left:postop op:'++' type:`d`
  | left:postop op:'--' type:`d`
  ;

singular
  =
  | literal
  | identifier
  | subexpr
  ;

subexpr
  =
  '(' @:expr ')'
  ;

literal
 =
 | int
 | str
 | chr
 | arr_lit
 ;

# array literals will be pointers if in an expression, otherwise expand into index setting if on rhs of an initialisation
arr_lit
  =
  '{' obj:','.{n:expr} '}'
  ;

int = val:/\d+/ ['_' size:('1' | '2' | '4' | '8')] ;
str = /".+"/ ;
chr = /'.'/ ;

identifier = /[A-Za-z]\w*/;